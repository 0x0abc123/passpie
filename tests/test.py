from glob import glob
import inspect
import os
import shutil
import sys
import unittest
import gnupg

# compat
try:
    from unittest.mock import patch, Mock
except ImportError:
    from mock import patch, Mock
if sys.version_info >= (3,):
    BUILTINS_NAME = "builtins"
else:
    BUILTINS_NAME = "__builtin__"

__file__ = os.path.abspath(inspect.getsourcefile(lambda _: None))

TEST_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)))
TEST_DATABASE_DIR = os.path.join(TEST_DIR, "database")

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from pysswords.db import Database
from pysswords.crypt import create_key_input
from pysswords.utils import touch, which
from pysswords.credential import Credential, CredentialNotFoundError
from pysswords import __main__, crypt


def build_key_dict():
    pysswords_input = {
        'name_real': 'Pysswords',
        'name_email': 'pysswords@pysswords',
        'name_comment': 'Automatically generated by Pysswords',
        'expire_date': 0,
        'key_type': 'RSA',
        'key_length': 1024,
        'key_usage': '',
        'subkey_type': 'RSA',
        'subkey_length': 1024,
        'subkey_usage': 'encrypt,sign,auth',
        'passphrase': 'testpassphrase'
    }
    return pysswords_input


def export_keys(binary, database_path, ascfile="key.asc"):
    gnupg_path = os.path.join(database_path, ".gnupg")
    gpg = gnupg.GPG(which(binary), homedir=gnupg_path)
    key_input = gpg.gen_key_input(**build_key_dict())
    key = gpg.gen_key(key_input)
    ascii_armored_public_keys = gpg.export_keys(key)
    ascii_armored_private_keys = gpg.export_keys(key, True)
    with open(ascfile, 'w') as f:
        f.write(ascii_armored_public_keys)
        f.write(ascii_armored_private_keys)
    return gpg


def import_keys(binary, database_path, ascfile="key.asc"):
    gnupg_path = os.path.join(database_path, ".gnupg")
    gpg = gnupg.GPG(which(binary), homedir=gnupg_path)
    key_data = open(ascfile).read()
    import_result = gpg.import_keys(key_data)
    print(import_result.results)


def setup_testing_database():
    binary = "gpg"
    database_path = os.path.join(TEST_DIR, "database")
    gnupg_path = os.path.join(database_path, ".gnupg")
    gpg = gnupg.GPG(which(binary), homedir=gnupg_path)

    keyfile = os.path.join(TEST_DIR, "key.asc")
    if not os.path.exists(keyfile):
        export_keys("gpg", database_path, keyfile)
    return gpg


def mock_create_gpg(binary, database_path, passphrase):
    # overwrite database_path with test database
    database_path = os.path.join(TEST_DIR, "database")
    gnupg_path = os.path.join(database_path, ".gnupg")
    gpg = gnupg.GPG(which(binary), homedir=gnupg_path)
    # gpg.gen_key(create_key_input(gpg, passphrase))
    return gpg


def build_credential(**kwargs):
    credential = Credential(
        name=kwargs.get("name", "example"),
        login=kwargs.get("login", "john"),
        password=kwargs.get("password", "my-great-password"),
        comments=kwargs.get("comments",
                            "This is login credentials for example")
    )
    return credential


def clean_credentials(database_path):
    for credential_dir in glob(database_path + "/**"):
        shutil.rmtree(os.path.relpath(credential_dir))


setup_testing_database()


@patch("pysswords.db.create_gpg", new=mock_create_gpg)
class PysswordsTests(unittest.TestCase):

    def setUp(self):
        self.database_path = os.path.join(TEST_DIR, "database")
        self.gnupg_path = os.path.join(self.database_path, ".gnupg")
        self.database_passphrase = build_key_dict().get("passphrase")
        self.database = Database.create(
            path=self.database_path,
            passphrase=self.database_passphrase
        )

    def tearDown(self):
        clean_credentials(self.database_path)

    def test_init_database_creates_gnupg_hidden_directory(self):
        self.assertTrue(os.path.exists(self.database_path))
        self.assertTrue(os.path.exists(self.gnupg_path))

    def test_credentials_are_a_list_of_credential_instances(self):
        self.database.add(build_credential(name="John1"))
        self.database.add(build_credential(name="John2"))
        self.database.add(build_credential(name="John3"))

        for credential in self.database.credentials:
            self.assertIsInstance(credential, Credential)

    def test_add_credential_creates_directory_with_credential_name(self):
        credential = build_credential()
        self.database.add(credential)
        credentials = self.database.credentials
        self.assertIn(credential.name, (c.name for c in credentials))

    def test_database_encrypt_uses_cipher_algo_aes256(self):
        self.database.gpg.encrypt = Mock()
        self.database.encrypt("text")
        self.assertTrue(self.database.gpg.encrypt.called)
        _, call_kwargs = self.database.gpg.encrypt.call_args
        self.assertEqual(call_kwargs.get("cipher_algo"), "AES256")

    def test_save_credential_creates_dir_with_cred_name_on_given_path(self):
        credential = build_credential()
        credential.save(database_path=self.database_path)
        credential_path = os.path.join(self.database_path, credential.name)
        self.assertTrue(os.path.exists(credential_path))
        self.assertTrue(os.path.isdir(credential_path))

    def test_credential_method_returns_expected_credential_object(self):
        name = "email"
        login = "email@example.com"
        password = "p4ssw0rd"
        comments = "email"
        credential = Credential(
            name=name,
            login=login,
            password=password,
            comments=comments
        )
        self.database.add(credential)
        expected_credential = self.database.credential(name=name)
        self.assertEqual(expected_credential.name, name)
        self.assertEqual(expected_credential.login, login)
        self.assertEqual(expected_credential.comments, comments)

    def test_get_credential_raises_expected_exception_when_not_found(self):
        with self.assertRaises(CredentialNotFoundError):
            self.database.credential(name="None")

    def test_edit_credential_in_database_saves_new_values(self):
        credential = build_credential()
        self.database.add(credential)
        new_name = "new_name"
        new_login = "new_login@example.com"
        new_comments = "new comments"
        values = {
            "name": new_name,
            "login": new_login,
            "comments": new_comments,
        }
        self.database.edit(name=credential.name, values=values)
        edited_credential = self.database.credential(name=new_name)
        self.assertEqual(edited_credential.login, new_login)
        self.assertEqual(edited_credential.comments, new_comments)

    def test_list_credentials_return_credentials_from_database_dir(self):
        credential_name = "email"
        credential_path = os.path.join(self.database_path, credential_name)
        os.makedirs(credential_path)
        touch(os.path.join(credential_path, "login"))
        touch(os.path.join(credential_path, "password"))
        touch(os.path.join(credential_path, "comments"))

        credentials = self.database.credentials
        self.assertIn(credential_name, (c.name for c in credentials))

    def test_remove_credential_deletes_files_credential_dir(self):
        credential = build_credential()
        self.database.add(credential)
        self.assertIn(credential.name, os.listdir(self.database_path))
        self.database.remove(name=credential.name)
        self.assertNotIn(credential.name, os.listdir(self.database_path))

    def test_search_database_returns_expected_credentials(self):
        credential = build_credential(
            name="twitter", login="pysswords")
        credential2 = build_credential(
            name="wikipedia", comments="nothing")
        self.database.add(credential)
        self.database.add(credential2)

        self.assertEqual(2, len(self.database.search("wi")))
        self.assertEqual(1, len(self.database.search("twitter")))
        self.assertEqual(1, len(self.database.search("nothing")))
        self.assertEqual(1, len(self.database.search("pysswords")))
        self.assertEqual(0, len(self.database.search("unknown")))

    def test_database_encrypt_returns_encrypted_text(self):
        encrypted = self.database.encrypt("testing text")
        self.assertIn("-----BEGIN PGP MESSAGE-----", encrypted)
        self.assertIn("-----END PGP MESSAGE-----", encrypted)

    def test_database_from_path_method_calls_load_gpg(self):
        path = "/tmp/pysswords"
        gpg_bin = "/usr/bin/gpg"
        with patch("pysswords.db.load_gpg") as mocked_load_gpg:
            Database.from_path(path, gpg_bin)
            mocked_load_gpg.assert_called_once_with(
                binary=gpg_bin,
                database_path=path
            )

    def test_database_from_path_method_returns_database_instance(self):
        path = "/tmp/pysswords"
        gpg_bin = "/usr/bin/gpg"
        with patch("pysswords.db.load_gpg"):
            database = Database.from_path(path, gpg_bin)
            self.assertIsInstance(database, Database)

    def test_get_gpg_return_valid_gpg_object(self):
        gpg = mock_create_gpg(
            binary="gpg2",
            database_path=self.database_path,
            passphrase="dummy"
        )
        self.assertIsInstance(gpg, gnupg.GPG)

    def test_database_key_input_returns_gpg_key_input_string(self):
        gpg = Mock()
        gpg.gen_key_input = Mock()
        passphrase = "dummy"
        testing = False
        create_key_input(gpg, passphrase, testing)
        gpg.gen_key_input.assert_called_once_with(
            name_real='Pysswords',
            name_email='pysswords@pysswords',
            name_comment='Autogenerated by Pysswords',
            passphrase=passphrase,
            testing=testing
        )


@patch("pysswords.db.create_gpg", new=mock_create_gpg)
class CryptTests(unittest.TestCase):

    def setUp(self):
        self.db_path = os.path.join(TEST_DIR, "database")
        self.gpg_path = os.path.join(self.db_path, ".gnupg")
        self.db_passphrase = build_key_dict().get("passphrase")
        self.gpg_binary = "gpg"

    def tearDown(self):
        clean_credentials(self.db_path)

    def test_crypt_create_gpg_returns_gpg_instance(self):
        with patch("pysswords.crypt.gnupg.GPG") as mocked_GPG:
            mock_create_gpg(self.gpg_binary, self.db_path, self.db_passphrase)
            mocked_GPG.assert_called_once_with(
                which(self.gpg_binary),
                homedir=self.gpg_path,
            )

    def test_crypt_create_gpg_generates_gpg_key(self):
        with patch("pysswords.crypt.gnupg.GPG") as mocked_gpg:
            crypt.create_gpg(self.gpg_binary, self.db_path, self.db_passphrase)
            self.assertTrue(mocked_gpg().gen_key.called)

    def test_crypt_create_gpg_creates_GPG_instance(self):
        with patch("pysswords.crypt.gnupg.GPG") as mocked_GPG:
            crypt.create_gpg(self.gpg_binary, self.db_path, self.db_passphrase)
            mocked_GPG.assert_called_once_with(
                which(self.gpg_binary),
                homedir=self.gpg_path
            )

    def test_crypt_load_gpg_creates_GPG_instance(self):
        with patch("pysswords.crypt.gnupg.GPG") as mocked_GPG:
            crypt.load_gpg(self.gpg_binary, self.db_path)
            mocked_GPG.assert_called_once_with(
                which(self.gpg_binary),
                homedir=self.gpg_path
            )

    def test_crypt_create_gpg_does_not_generates_gpg_key(self):
        database_path = "/tmp/dummydb"
        with patch("pysswords.crypt.gnupg.GPG") as mocked_gpg:
            crypt.load_gpg(self.gpg_binary, database_path)
            self.assertFalse(mocked_gpg().gen_key.called)


class CredentialTests(unittest.TestCase):

    def test_credential_str_magic_methods_has_shows_name_login(self):
        credential = build_credential()
        self.assertIn(credential.name, str(credential))
        self.assertIn(credential.login, str(credential))


class UtilsTests(unittest.TestCase):
    def setUp(self):
        os.makedirs(os.path.join(TEST_DIR, "data"))

    def tearDown(self):
        shutil.rmtree(os.path.join(TEST_DIR, "data"))

    def test_touch_function(self):
        touched_file = os.path.join(TEST_DIR, "data", "touched.txt")
        with patch("{}.open".format(BUILTINS_NAME)) as mocker:
            touch(touched_file)
            mocker.assert_called_once_with(touched_file, "a")

    def test_which_function_returns_expected_binary_path(self):
        python_path = which("python")
        self.assertEqual(os.path.basename(python_path), "python")

    def test_which_function_appends_exe_when_os_name_is_nt(self):
        with patch("pysswords.utils.os") as mocker:
            mocker.name = "nt"
            mocker.environ = {"PATH": "/"}
            mocker.pathsep = ":"
            mocked_join = Mock()
            mocker.path.join = mocked_join
            which("python")
            mocked_join.assert_any_call("/", "python.exe")


@patch("pysswords.db.create_gpg", new=mock_create_gpg)
class ConsoleInterfaceTests(unittest.TestCase):

    def setUp(self):
        self.gpg_binary = "gpg"
        self.db_path = TEST_DATABASE_DIR
        self.gpg_path = os.path.join(self.db_path, ".gnupg")
        self.db_passphrase = build_key_dict().get("passphrase")
        self.database = Database.create(
            path=self.db_path,
            passphrase=self.db_passphrase,
            gpg_bin=which(self.gpg_binary)
        )

    def tearDown(self):
        clean_credentials(self.db_path)

    def test_args_init_without_path_uses_home_user_dotpysswords(self):
        args = __main__.get_args(["--init"])
        self.assertEqual(args.database, __main__.default_database_path())

    def test_run_with_init_args_creates_new_database(self):
        args = __main__.get_args(["--init"])
        pwd = self.db_passphrase
        with patch("pysswords.__main__.get_password", return_value=pwd):
            with patch("pysswords.__main__.Database.create") as mocked:
                __main__.run(args)
                mocked.assert_called_once_with(
                    path=__main__.default_database_path(),
                    passphrase=pwd,
                    gpg_bin=__main__.default_gpg_binary()
                )

    def test_getpassphrase_raises_value_error_when_passwords_didnt_match(self):
        with patch("{}.print".format(BUILTINS_NAME)):
            with patch("pysswords.__main__.getpass") as mocked:
                mocked.side_effect = ["pass", "wrong"] * 3
                with self.assertRaises(ValueError):
                    __main__.get_password()

    def test_interface_handles_gpg_binary_argument(self):
        args = __main__.get_args(["--gpg", self.gpg_binary, "--init"])
        pwd = self.db_passphrase
        with patch("pysswords.__main__.get_password", return_value=pwd):
            with patch("pysswords.__main__.Database.create") as mocked:
                __main__.run(args)
                mocked.assert_called_once_with(
                    path=__main__.default_database_path(),
                    passphrase=self.db_passphrase,
                    gpg_bin=self.gpg_binary
                )

    def test_console_inteface_init_logs_path_to_database(self):
        args = __main__.get_args(["--init"])
        mockdb = Mock()
        mockdb.path = "path"
        with patch("pysswords.__main__.init_database", return_value=mockdb):
            with patch("pysswords.__main__.logging") as mocklog:
                __main__.run(args)
                log_message = "Database created at '{}'".format(mockdb.path)
                mocklog.info.assert_called_once_with(log_message)

    def test_interface_check_passphrase_throws_error_wrong_passphrase(self):
        mocked_db = Mock()
        mocked_db.gpg.sign.return_value = False
        with self.assertRaises(ValueError):
            __main__.check_passphrase(database=mocked_db, passphrase="dummy")

    def test_get_args_raise_parser_error_when_arg_clipboard_without_get(self):
        with open(os.devnull, 'w') as devnull:
            with patch("sys.stderr", devnull):
                with self.assertRaises(SystemExit):
                    __main__.get_args("-c".split())

    def test_check_passphrase_raises_value_error_for_wrong_passphrase(self):
        mockdb = Mock()
        mockdb.gpg.sign.return_value = False
        passphrase = "dummy"
        with self.assertRaises(ValueError):
            __main__.check_passphrase(mockdb, passphrase)

    def test_build_row_with_show_password_false_has_hidden_password(self):
        credential = build_credential()
        self.database.add(credential)
        name, login, password, comments = __main__.build_row(
            database=self.database,
            credential=credential,
            show_password=False
        )
        expected_password = "****"
        self.assertEqual(expected_password, password)

    def test_build_row_with_show_password_true_writes_plaintext_password(self):
        credential = build_credential()
        self.database.add(credential)
        to_patch = "pysswords.__main__.getpass"
        with patch(to_patch, return_value=self.db_passphrase):
            _, _, password, _ = __main__.build_row(
                self.database,
                credential,
                show_password=True
            )
            decrypted_password = self.database.decrypt(
                text=credential.password,
                passphrase=self.db_passphrase
            )
            self.assertEqual(decrypted_password, password)

    def test_get_password_returns_password_when_passwords_match(self):
        password = "password"
        with patch("pysswords.__main__.getpass") as mocked_getpass:
            mocked_getpass.side_effect = [password, password]
            result = __main__.get_password()
            self.assertEqual(result, password)

    def test_list_credentials_print_all_credentials(self):
        credential_one = build_credential(
            name="example",
            login="py@example",
            comments="example account"
        )
        self.database.add(credential_one)

        credential_two = build_credential(
            name="bank",
            login="None",
            comments="Credit card"
        )
        self.database.add(credential_two)

        from io import StringIO
        with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
            __main__.list_credentials(self.database)
            output = mock_stdout.getvalue()
        self.assertIn(credential_one.name, output)
        self.assertIn(credential_one.login, output)
        self.assertIn(credential_one.comments, output)
        self.assertIn(credential_two.name, output)
        self.assertIn(credential_two.login, output)
        self.assertIn(credential_two.comments, output)

    def test_prompt_credential_returns_credential_instance(self):
        py3 = sys.version_info >= (3,)
        to_patch = "builtins.input" if py3 else "pysswords.__main__.input"
        with patch(to_patch, return_value="x"):
            with patch("pysswords.__main__.get_password", return_value="y"):
                credential = __main__.prompt_credential()
                self.assertIsInstance(credential, Credential)


if __name__ == "__main__":
    if sys.version_info >= (3, 1):
        unittest.main(warnings="ignore")
    else:
        unittest.main()
